---
title: 记录博客的迁移和全面开启HTTPS 
date: 2017-11-01 22:52:29   
toc: true 
tags:
  - linux
  - vps
thumbnail: https://ws3.sinaimg.cn/large/006tNc79gy1fl7pl5sysxj31kw11xgpp.jpg
---

起因是想给博客开启小绿锁，但是之前我的博客是托管在 git page 上的,所以打算用 cloudFlare 提供的免费 SSL 证书。奈何它只是浏览器到 cloudFlare 之间是加密的，个人还是喜欢端到端加密。
正好有一台写爬虫的vps,于是花了半天折腾了下迁移了博客。


## 环境
**PC: MacOS High Sierra@10.13**

**VPS: Vultr**

**VPS-OS:  CentOS 7.4.1708 x64**


## 方案选择

框架选择: [Hexo 快速、简洁且高效的静态博客框架](https://hexo.io/zh-cn/)

主题选择: [Material Theme](https://github.com/viosey/hexo-theme-material)

关于 hexo 和主题、域名配置就不赘述了，毕竟个人口味不同，适合自己的就是最好的。所以假设我们本地的 hexo 是已经配置好的，域名也已选购并指向我们的 vps，本文主要记录的是关于 vps 环境配置的注意点。

## 博客环境搭建

### 新增用户

我们要在 vps 上新增一个用户部署博客

```bash
# 登录 vps 
ssh -o ServerAliveInterval=60 root@0.0.0.0 -p 4399  # 0.0.0.0换成你的ip 4399换成你的端口
# 添加用户
useradd hexo
# 修改密码
passwd hexo
# 赋予用户 root 权限
visudo
# 找到这一行并添加:
root        ALL=(ALL)       ALL  # 查找的一行
hexo        ALL=(ALL)       ALL  # 添加的一行
```

### 禁止 root 登录
这一步我们要切换到本地terminal,配置免密码登录禁止root用户登录

mac切换超级用户

```
sudo -s
cd /var/root/
mkdir .ssh && cd .ssh
```

生成 ssh-key

```
ssh-keygen -t rsa
```

将下面命令打印出来的内容复制下来，这就是你的公钥

```
cat id_rsa.pub
```

配置 ssh config

```
vi config
```

将一下内容修改并复制进 config

```
# --- blog ---
Host 0.0.0.0            # 修改成你的vps ip
    HostName 0.0.0.0    # 修改成你的vps ip
    User hexo           # 修改成你的user name
    Port 4399           # 修改成你的vps ssh 端口号
    IdentityFile /var/root/.ssh/id_rsa.pub
```

关于这里为何要将config放在`/var/root/`而不是`/Users/yourname/.ssh`下，可以看下这个[issues](https://github.com/hexojs/hexo-deployer-git/issues/59)，后面自动化部署也会讲。

下面要切换回vps的terminal

```bash
# 切换到你刚刚创建的用户
su hexo
# 将公钥放置
cd ~
mkdir .ssh && cd .ssh
echo "公钥(全部内容)" > authorized_keys
# 确认下权限正常
chmod 700 ~/.ssh/
chmod 600 ~/.ssh/authorized_keys

```

编辑 ssh-config

```
vi /etc/ssh/sshd_config
```
修改一下内容

```
PermitRootLogin no  # 修改yes为no
AllowUsers hexo
```

重启ssh服务

```
systemctl restart sshd.service
```

这个时候不要关闭当前的连接，另外开一个连接进行测试 root 是否能登录。同时保证有其他用户可以登录，如果其他用户不能登录还能改回来。否则你关闭了连接又没有其他账号可登录。想要控制远程的服务器，呵呵。

关于其他服务器安全的基本配置你可以看下我上篇文章[记录vps的搭建和基本安全防护](https://www.theseusv.com/2017/10/07/%E8%AE%B0%E5%BD%95vps%E6%90%AD%E5%BB%BA/)。

### 安装依赖

```bash
# 切换 root 用户
su
# 首先更新一下
yum upgrade -y 
# 添加 EPEL 源   EPEL 是yum的一个软件源，里面包含了许多基本源里没有的软件。
yum -y install epel-release
# 检查EPEL源
yum repolist
# 运行命令生成缓存
yum clean all && yum makecache
# 安装 git 和 nginx
yum install nginx git -y
# 检查一下版本
nginx -v 
git -v
```

### 初始化站点文件
```bash
# 切换 root 用户
su
# Nginx 默认把网页文件存在 /var/www 目录
cd /var/www
mkdir blog
# 确认权限
chmod 755 blog
chown hexo -R /var/www/blog
```

### 初始化 git 仓库并配置 hooks
```bash
# 切换用户 注意，一定切换，不然会产生权限问题
su hexo 
cd ~
mkdir hexo.git && cd hexo.git
# 初始化 git 仓库
git init --bare
cd hooks
vi post-receive
```

将一下内容复制进去并保存

```bash
!/bin/bash

GIT_REPO=~/hexo.git                      # 空 Git 仓库的文件夹，触发 hook 时已经存入了内容
TMP_GIT_CLONE=/tmp/hexo                  # 缓存文件夹，存在 /tmp 下可以随意读写
PUBLIC_WWW=/var/www/blog                 # 之前创建的 blog 文件夹，用作网站主目录
rm -rf ${TMP_GIT_CLONE}                  # 删除缓存的全部内容
git clone ${GIT_REPO} ${TMP_GIT_CLONE}   # 将 Git 仓库被上传的内容写入缓存
rm -rf ${PUBLIC_WWW}/*                   # 删除网站主目录全部内容
cp -rf ${TMP_GIT_CLONE}/* ${PUBLIC_WWW}  # 将缓存目录所有内容复制到主目录
```

确认下权限

```bash
chmod +x post-receive
```

### Nginx配置
NGINX 是一个功能强大的 HTTP 反向代理服务器，支持负载均衡等等特性。

```bash
# 切换 root 用户
su
# 进入 nginx 配置目录
cd /etc/nginx/config.d
vi blog.conf
```

将一下内容复制修改并保存

```bash
server {
        listen 80;
        listen [::]:80;

        # Self signed certs generated by the ssl-cert package
        # Don't use them in a production server!
        #
        # include snippets/snakeoil.conf;

        # ====== 2 ======
        root /var/www/blog;
        # ====== 2 ======

        # Add index.php to the list if you are using PHP
        index index.html index.htm index.nginx-debian.html;

        # ====== 1 ======
        server_name yoursite.com;
        # ====== 1 ======

        location ~* ^.+\.(ico|gif|jpg|jpeg|png)$ {
                # ====== 2 ======
                root /var/www/blog;
                # ====== 2 ======
                access_log   off;
                expires      1d;
        }
        location ~* ^.+\.(css|js|txt|xml|swf|wav)$ {
                # ====== 2 ======
                root /var/www/blog;
                # ====== 2 ======
                access_log   off;
                expires      10m;
        }
        location / {
                # ====== 2 ======
                root /var/www/blog;
                # ====== 2 ======
                if (-f $request_filename) {
                        rewrite ^/(.*)$  /$1 break;
                }
        }
}
```

重启nginx服务

```
systemctl restart nginx
```

注:

	1. 你的域名
	2. 站点文件目录

### HEXO DEPLOY 设置

这一步我们要切换到本地terminal

```bash
# 进入你已设置好的 hexo 目录
cd /path/to/your/hexo
# 安装 hexo-deployer-git
npm install hexo-deployer-git --save
# 编辑 _config.yml
vi _config.yml
```

修改并保存

```bash
deploy:
  type: git                      # 设置上传模块为 Git
  repo: hexo@0.0.0.0:hexo.git    # 换成你 VPS 的 IP ，使用 hexo 用户登录，上传到 hexo.git
  branch: master                 # 存储在 master 分支（主分支）
```

### 部署上传

```bash
# 清除缓存文件，生成静态页面
hexo clean && hexo g
# 在 http://localhost:4000  预览
hexo s
# 上传 因为 hexo 是从 /var/root/.ssh 读取 ssh-config ，所以要加 sudo
sudo hexo d
```

恭喜你，这样就基本完成了，你就可以访问你的域名看到你的网站了。

## HTTPS 全面开启
如果要启用HTTPS，我们就需要从证书授权机构(以下简称CA) 处获取一个证书，我现在使用的是 Let's Encrypt 提供的服务。

### 获取免费的证书

> Certbot 是Let's Encrypt官方推荐的获取证书的客户端，可以帮我们获取免费的Let's Encrypt 证书。

安装Certbot客户端

```bash
su
yum install certbot -y
```

自动生成证书:

1. `certbot certonly --webroot -w /var/www/blog -d example.com -d www.example.com`
2. `certbot certonly --standalone -d example.com -d www.example.com`

上述两种方法都能生成证书，区别是:

- `--webroot` 模式会在 `/var/www/example` 中创建 `.well-known` 文件夹，这个文件夹里面包含了一些验证文件，certbot 会通过访问 `example.com/.well-known/acme-challenge` 来验证你的域名是否绑定的这个服务器。 
- `--standalone` ， 这种模式不需要指定网站根目录，他会自动启用服务器的443端口，来验证域名的归属。我们有其他服务（例如nginx）占用了443端口，就必须先停止这些服务 `systemctl stop nginx` ，在证书生成完毕后，再启用`systemctl start nginx`。


证书生成完毕后，我们可以在 `/etc/letsencrypt/live/` 目录下看到对应域名的文件夹，里面存放了指向证书的一些快捷方式。

### Nginx 配置启用 HTTPS

我们可以参考[Mozilla SSL Configuration Generator](https://mozilla.github.io/server-side-tls/ssl-config-generator/)生成我们自己的 nginx 配置，这里生成的配置文件是业界最佳实践和结果，让 nginx 打开了各种增加安全性和性能的参数。

下面是我自己的配置:

```bash
server {
    listen 80;
    listen [::]:80;
    
    # ====== 1 ======
    server_name www.example.com;
    # ====== 1 ======
    
    # Redirect all HTTP requests to HTTPS with a 301 Moved Permanently response.
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;

    # ====== 2 ======
    root /var/www/blog;
    # ====== 2 ======

    
    # certs sent to the client in SERVER HELLO are concatenated in ssl_certificate
    
    # ====== 3 ======
    ssl_certificate /path/to/signed_cert_plus_intermediates;
    ssl_certificate_key /path/to/private_key;
    # ====== 3 ======
    
    ssl_session_timeout 1d;
    ssl_session_cache shared:SSL:50m;
    ssl_session_tickets off;

    # Diffie-Hellman parameter for DHE ciphersuites, recommended 2048 bits
    
    # ====== 4 ======
    ssl_dhparam /path/to/dhparam.pem;
    # ====== 4 ======

    # intermediate configuration. tweak to your needs.
    ssl_protocols TLSv1 TLSv1.1 TLSv1.2;
    ssl_ciphers 'ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-AES128-SHA256:ECDHE-RSA-AES128-SHA256:ECDHE-ECDSA-AES128-SHA:ECDHE-RSA-AES256-SHA384:ECDHE-RSA-AES128-SHA:ECDHE-ECDSA-AES256-SHA384:ECDHE-ECDSA-AES256-SHA:ECDHE-RSA-AES256-SHA:DHE-RSA-AES128-SHA256:DHE-RSA-AES128-SHA:DHE-RSA-AES256-SHA256:DHE-RSA-AES256-SHA:ECDHE-ECDSA-DES-CBC3-SHA:ECDHE-RSA-DES-CBC3-SHA:EDH-RSA-DES-CBC3-SHA:AES128-GCM-SHA256:AES256-GCM-SHA384:AES128-SHA256:AES256-SHA256:AES128-SHA:AES256-SHA:DES-CBC3-SHA:!DSS';
    ssl_prefer_server_ciphers on;

    # HSTS (ngx_http_headers_module is required) (15768000 seconds = 6 months)
    add_header Strict-Transport-Security max-age=15768000;

    # OCSP Stapling ---
    # fetch OCSP records from URL in ssl_certificate and cache them
    ssl_stapling on;
    ssl_stapling_verify on;

    ## verify chain of trust of OCSP response using Root CA and Intermediate certs
    # ssl_trusted_certificate /path/to/root_CA_cert_plus_intermediates;
    
    
    # ====== 5 ======
    resolver  ns1.vultr.com ns2.vultr.com;
    # ====== 5 ======


}
```

注:

1. server_name 对应你的域名
2. root 对应你的站点文件目录
3. ssl_certificate 和 ssl_certificate_key ，分别对应 fullchain.pem 和 privkey.pem，这2个文件是 `/etc/letsencrypt/live/exapmle.com` 下之前就生成好的证书和密钥。
4. ssl_dhparam 通过下面命令生成:`mkdir /etc/nginx/ssl `  `openssl dhparam -out /etc/nginx/ssl/dhparam.pem 2048`
5. resolver 是用來解析 OCSP 服務器的域名的，建议填写你的 VPS 提供商的 DNS 服务器，我填写的就是 vultr 的 dns 服务器。


重启 nginx 服务器

```bash
systemctl restart nginx
```

### 自动更新 SSL 证书
Let's Encrypt 提供的证书只有三个月的有效期。
通过下面这个命令，他会自动检查系统内的证书，并且自动更新这些证书:

```bash
certbot renew --dry-run 
```

## 问题总结

- 如果遇到 nginx 启动失败，可以运行 `nginx -t` 来看下哪边报错。
- 如果遇到 deploy 失败了，先检查 `hexo-deployer-git` 是否安装，再到 `/var/root/.ssh` 检查 config 文件。
- 如果遇到 deploy 成功了，访问域名还是 nginx 默认页面，你可以到 vps 上手动 git hooks测试下，一般都是权限问题。


## References

1. [Let's Encrypt 给网站加 HTTPS 完全指南](https://ksmx.me/letsencrypt-ssl-https/)
2. [手把手教你搭建 Hexo 到 VPS](https://pondof.fish/d/31)

